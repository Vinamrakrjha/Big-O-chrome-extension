export const data = [
    //Searching Alogrithms
    {
        Ds : "Binary Search",
        Tc : "O(log(n))",
        Sc : "O(1)"
    },
    {
        Ds : "Linear Search",
        Tc : "O(n)",
        Sc : "O(1)"
    },
    {
        Ds : "Unbounded Binary Search",
        Tc : "O(log(n))",
        Sc : "O(1)"
    },

    //Sorting Algorithms
    {
        Ds : "Quick Sort",
        Tc : "O(n^2)",
        Sc : "O(log(n))"
    },
    {
        Ds : "Merge Sort",
        Tc : "O(n log(n))",
        Sc : "O(n)"
    },
    {
        Ds : "Tim Sort",
        Tc : "O(n log(n))",
        Sc : "O(n)"
    },
    {
        Ds : "Heap Sort",
        Tc : "O(n log(n))",
        Sc : "O(1)"
    },
    {
        Ds : "Bubble Sort",
        Tc : "O(n^2)",
        Sc : "O(1)"
    },
    {
        Ds : "Insertion Sort",
        Tc : "O(n^2)",
        Sc : "O(1)"
    },
    {
        Ds : "Selection Sort",
        Tc : "O(n^2)",
        Sc : "O(1)"
    },
    {
        Ds : "Tree Sort",
        Tc : "O(n^2)",
        Sc : "O(n)"
    },
    {
        Ds : "Shell Sort",
        Tc : "O(n(log(n))^2)",
        Sc : "O(1)"
    },
    {
        Ds : "Bucket Sort",
        Tc : "O(n^2)",
        Sc : "O(n)"
    },
    {
        Ds : "Radix Sort",
        Tc : "O(nk)",
        Sc : "O(n+k)"
    },
    {
        Ds : "Counting Sort",
        Tc : "O(n+k)",
        Sc : "O(k)"
    },
    {
        Ds : "Cube Sort",
        Tc : "O(n log(n))",
        Sc : "O(n)"
    },
    {
        Ds : "Dutch National Flag Algorithm",
        Tc : "O(n)",
        Sc : "O(1)"
    },

    //Binary Tree
    {
        Ds : "BFS in Binary Tree",
        Tc : "O(n)",
        Sc : "O(n)"
    },
    {
        Ds : "DFS in Binary Tree",
        Tc : "O(n)",
        Sc : "O(n)"
    },

    // Binary Search Tree
    
    {
        Ds : "Insertion in Binary Search Tree",
        Tc : "O(n)",
        Sc : "O(n)"
    },
    {
        Ds : "Deletion in Binary Search Tree",
        Tc : "O(n)",
        Sc : "O(n)"
    },
    {
        Ds : "Searching in Binary Search Tree",
        Tc : "O(n)",
        Sc : "O(n)"
    },

    // AVL Tree

    {
        Ds : "Deletion in AVL Tree",
        Tc : "O(log(n))",
        Sc : "O(n)"
    },
    {
        Ds : "Searching in AVL Tree",
        Tc : "O(log(n))",
        Sc : "O(n)"
    },
    {
        Ds : "Insertion in AVL Tree",
        Tc : "O(log(n))",
        Sc : "O(n)"
    },

    // Red-Black Tree

    {
        Ds : "Deletion in Red Black Tree",
        Tc : "O(log(n))",
        Sc : "O(n)"
    },
    {
        Ds : "Searching in Red Black Tree",
        Tc : "O(log(n))",
        Sc : "O(n)"
    },
    {
        Ds : "Insertion in Red Black Tree",
        Tc : "O(log(n))",
        Sc : "O(n)"
    },

    // Hash Table

    {
        Ds : "Deletion in Hash Table",
        Tc : "O(n)",
        Sc : "O(n)"
    },
    {
        Ds : "Searching in Hash Table",
        Tc : "O(n)",
        Sc : "O(n)"
    },
    {
        Ds : "Insertion in Hash Table",
        Tc : "O(n)",
        Sc : "O(n)"
    },

    //String Pattern Matching ALgorithms
    {
        Ds : "Rabin Karp Algorithm",
        Tc : "O((n-m+1) m)",
        Sc : "O(1)"
    },
    {
        Ds : "Knuth-Morris-Pratt Algorithm",
        Tc : "O(n+m)",
        Sc : "O(m)"
    },
    {
        Ds : "Boyer Moore Algorithm for Pattern Searching",
        Tc : "O(n*m)",
        Sc : "O(1)"
    },
    {
        Ds : "Naive Pattern Searching Algorithm",
        Tc : "O((n-m+1) m)",
        Sc : "O(1)"
    },

    //linked lists
    {
        Ds : "Deletion in Singly/Doubly linked list",
        Tc : "O(1)",
        Sc : "O(1)"
    },
    {
        Ds : "Searching in Singly/Doubly linked list",
        Tc : "O(n)",
        Sc : "O(1)"
    },
    {
        Ds : "Insertion in Singly/Doubly linked list",
        Tc : "O(1)",
        Sc : "O(1)"
    },
    {
        Ds : "Floyd's cycle detection alogrithm",
        Tc : "O(n)",
        Sc : "O(1)"
    },

    //Queue

    {
        Ds : "Deletion in Queue",
        Tc : "O(1)",
        Sc : "O(1)"
    },
    {
        Ds : "Searching in Queue",
        Tc : "O(n)",
        Sc : "O(n)"
    },
    {
        Ds : "Insertion in Queue",
        Tc : "O(1)",
        Sc : "O(1)"
    },

    //Stack

    {
        Ds : "Deletion in Stack",
        Tc : "O(1)",
        Sc : "O(1)"
    },
    {
        Ds : "Searching in Stack",
        Tc : "O(n)",
        Sc : "O(n)"
    },
    {
        Ds : "Insertion in Stack",
        Tc : "O(1)",
        Sc : "O(1)"
    },

    //Heap
    {
        Ds : "Building Heap",
        Tc : "O(n)",
        Sc : "O(h)"
    },

    //Graph
    {
        Ds : "Djikstra's Algorithm",
        Tc : "O(V^2)",
        Sc : "O(V)"
    },
    {
        Ds : "Floyd Warshall's Algorithm",
        Tc : "O(V^3)",
        Sc : "O(V^2)"
    },
    {
        Ds : "Bellman Ford's Algorithm",
        Tc : "O(V*E)",
        Sc : "O(V)"
    },
    {
        Ds : "Kruskal's Algorithm",
        Tc : "O(E log(E))",
        Sc : "O(V)"
    },
    {
        Ds : "Prism Kirchoff's Algorithm",
        Tc : "O(V^4)",
        Sc : "O(V^2)"
    },
    {
        Ds : "Kosaraju's Algorithm",
        Tc : "O(V+E)",
        Sc : "O(V)"
    },
    {
        Ds : "Kahn's Algorithm",
        Tc : "O(V+E)",
        Sc : "O(V)"
    },
    {
        Ds : "Tarjan's Algorithm",
        Tc : "O(V+E)",
        Sc : "O(V)"
    },
    {
        Ds : "Prim's Algorithm",
        Tc : "O(E log(V))",
        Sc : "O(V+E)"
    },
    {
        Ds : "BFS in Graph",
        Tc : "O(V+E)",
        Sc : "O(V)"
    },
    {
        Ds : "DFS in Graph",
        Tc : "O(V+E)",
        Sc : "O(V)"
    },

    // more algos....

    {
        Ds : "Euclid's Algorithm",
        Tc : "O(log(min(a,b)))",
        Sc : "O(1)"
    },
    {
        Ds : "Sieve of Eratosthenes",
        Tc : "O(n log(log(n)))",
        Sc : "O(n)"
    },
    {
        Ds : "Brian Kernighan's Algorithm",
        Tc : "O(log(n))",
        Sc : "O(1)"
    },
    {
        Ds : "Lookup Table method",
        Tc : "O(1)",
        Sc : "O(1)"
    },
    {
        Ds : "Kadane's Algorithm",
        Tc : "O(n)",
        Sc : "O(1)"
    },
    {
        Ds : "Boyer-Moore Majority Voting Algorithm",
        Tc : "O(n)",
        Sc : "O(1)"
    },
    {
        Ds : "Two Pointer Approach",
        Tc : "O(n)",
        Sc : "O(1)"
    },

    //Trie
    {
        Ds : "Deletion in Trie",
        Tc : "O(n)",
        Sc : "O(1)"
    },
    {
        Ds : "Searching in Trie",
        Tc : "O(n)",
        Sc : "O(1)"
    },
    {
        Ds : "Insertion in Trie",
        Tc : "O(n)",
        Sc : "O(n)"
    }, 
    
    // Segment Tree
    {
        Ds : "Constructing a Segment Tree",
        Tc : "O(n)",
        Sc : "O(n)"
    },
    {
        Ds : "Range Query in a Segment Tree",
        Tc : "O(log(n))",
        Sc : "O(n)"
    },
    {
        Ds : "Updation in a Segment Tree",
        Tc : "O(log(n))",
        Sc : "O(n)"
    }
]

